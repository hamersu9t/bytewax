<main class="api__content">
<article class="api__article" id="content">
<header class="api__article-header">
<h1 class="api__article-title">Module <strong>bytewax.inputs</strong></h1>
</header>
<section class="api__article-intro" id="section-intro">
<p>Low-level input interfaces.</p>
<p>If you want pre-built connectors for various external systems, see
<code><a title="bytewax.connectors" href="/apidocs/bytewax.connectors/index">bytewax.connectors</a></code>. That is also a rich source of examples.</p>
<p>Subclass the types here to implement input for your own custom source.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">&#34;&#34;&#34;Low-level input interfaces.

If you want pre-built connectors for various external systems, see
`bytewax.connectors`. That is also a rich source of examples.

Subclass the types here to implement input for your own custom source.

&#34;&#34;&#34;

from abc import abstractmethod
from typing import Any, Iterable, Optional, Tuple

PartIter = Iterable[Optional[Tuple[Any, Any]]]
&#34;&#34;&#34;A single partition.

Each partition must contain unique data. If you re-read the same data
in multiple partitions, the dataflow will process these duplicate
items.

It must yield a two-tuple of `(state, item)` where the state will be
returned to you via the `resume_state` parameter of
`PartInput.build_part`.

If this is a generator, it must do a kind of cooperative
multi-tasking, never blocking but yielding a bare `None` if there is
no new input.

Yields:

    Either a new item and state, or `None`.

&#34;&#34;&#34;


# TODO: Add ABC superclass. It messes up pickling. We should get rid
# of pickling...
class PartInput:
    &#34;&#34;&#34;An input source with a fixed number of independent partitions.&#34;&#34;&#34;

    @abstractmethod
    def list_parts(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;List all partitions for this input by a string key.

        This must consistently return the same keys when called by any
        worker in a cluster.

        Keys must be unique within this list.

        Returns:

            Partition keys.

        &#34;&#34;&#34;
        ...

    @abstractmethod
    def build_part(
        self,
        for_part: str,
        resume_state: Optional[Any],
    ) -&gt; Optional[PartIter]:
        &#34;&#34;&#34;Build an input source for a given partition, resuming from
        the position encoded in the resume state.

        Be careful of &#34;off by one&#34; errors in resume state. This should
        return a source that resumes from _the next item_, not the
        same item that the state was paired with.

        Return `None` if for some reason this partition is no longer
        valid and can be skipped coherently. Raise an exception if
        not.

        Do not pre-build state about a partition in the
        constructor. All state must be derived from `resume_state` for
        recovery to work properly.

        Args:

            for_part: Which partition to build.

            resume_state: State data containing where in the input
                stream this partition should be begin on this invocation.

        Returns:

            The built partition, or `None`.

        &#34;&#34;&#34;
        ...

    def __json__(self):
        &#34;&#34;&#34;This is used by the Bytewax platform internally and should
        not be overridden.

        &#34;&#34;&#34;
        return {
            &#34;type&#34;: type(self).__name__,
        }</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="api__article-subtitle" id="header-variables">Global variables</h2>
<dl>
<dt id="bytewax.inputs.PartIter"><code class="language-python name">var <span class="ident">PartIter</span></code></dt>
<dd>
<div class="desc"><p>A single partition.</p>
<p>Each partition must contain unique data. If you re-read the same data
in multiple partitions, the dataflow will process these duplicate
items.</p>
<p>It must yield a two-tuple of <code>(state, item)</code> where the state will be
returned to you via the <code>resume_state</code> parameter of
<code><a title="bytewax.inputs.PartInput.build_part" href="/apidocs/bytewax.inputs#bytewax.inputs.PartInput.build_part">PartInput.build_part()</a></code>.</p>
<p>If this is a generator, it must do a kind of cooperative
multi-tasking, never blocking but yielding a bare <code>None</code> if there is
no new input.</p>
<h2 id="yields">Yields</h2>
<p>Either a new item and state, or <code>None</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="api__article-subtitle" id="header-classes">Classes</h2>
<dl>
<dt id="bytewax.inputs.PartInput"><code class="language-python flex name class">
<span>class <span class="ident">PartInput</span></span>
</code></dt>
<dd>
<div class="desc"><p>An input source with a fixed number of independent partitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">class PartInput:
    &#34;&#34;&#34;An input source with a fixed number of independent partitions.&#34;&#34;&#34;

    @abstractmethod
    def list_parts(self) -&gt; Iterable[str]:
        &#34;&#34;&#34;List all partitions for this input by a string key.

        This must consistently return the same keys when called by any
        worker in a cluster.

        Keys must be unique within this list.

        Returns:

            Partition keys.

        &#34;&#34;&#34;
        ...

    @abstractmethod
    def build_part(
        self,
        for_part: str,
        resume_state: Optional[Any],
    ) -&gt; Optional[PartIter]:
        &#34;&#34;&#34;Build an input source for a given partition, resuming from
        the position encoded in the resume state.

        Be careful of &#34;off by one&#34; errors in resume state. This should
        return a source that resumes from _the next item_, not the
        same item that the state was paired with.

        Return `None` if for some reason this partition is no longer
        valid and can be skipped coherently. Raise an exception if
        not.

        Do not pre-build state about a partition in the
        constructor. All state must be derived from `resume_state` for
        recovery to work properly.

        Args:

            for_part: Which partition to build.

            resume_state: State data containing where in the input
                stream this partition should be begin on this invocation.

        Returns:

            The built partition, or `None`.

        &#34;&#34;&#34;
        ...

    def __json__(self):
        &#34;&#34;&#34;This is used by the Bytewax platform internally and should
        not be overridden.

        &#34;&#34;&#34;
        return {
            &#34;type&#34;: type(self).__name__,
        }</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bytewax.connectors.files.DirInput" href="/apidocs/bytewax.connectors/files#bytewax.connectors.files.DirInput">DirInput</a></li>
<li><a title="bytewax.connectors.files.FileInput" href="/apidocs/bytewax.connectors/files#bytewax.connectors.files.FileInput">FileInput</a></li>
<li><a title="bytewax.connectors.kafka.KafkaInput" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaInput">KafkaInput</a></li>
<li><a title="bytewax.testing.TestingInput" href="/apidocs/bytewax.testing#bytewax.testing.TestingInput">TestingInput</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bytewax.inputs.PartInput.build_part"><code class="language-python name flex">
<span>def <span class="ident">build_part</span></span>(<span>self, for_part: str, resume_state: Optional[Any]) ‑> Optional[Iterable[Optional[Tuple[Any, Any]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Build an input source for a given partition, resuming from
the position encoded in the resume state.</p>
<p>Be careful of "off by one" errors in resume state. This should
return a source that resumes from <em>the next item</em>, not the
same item that the state was paired with.</p>
<p>Return <code>None</code> if for some reason this partition is no longer
valid and can be skipped coherently. Raise an exception if
not.</p>
<p>Do not pre-build state about a partition in the
constructor. All state must be derived from <code>resume_state</code> for
recovery to work properly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>for_part</code></strong></dt>
<dd>Which partition to build.</dd>
<dt><strong><code>resume_state</code></strong></dt>
<dd>State data containing where in the input
stream this partition should be begin on this invocation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The built partition, or <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@abstractmethod
def build_part(
    self,
    for_part: str,
    resume_state: Optional[Any],
) -&gt; Optional[PartIter]:
    &#34;&#34;&#34;Build an input source for a given partition, resuming from
    the position encoded in the resume state.

    Be careful of &#34;off by one&#34; errors in resume state. This should
    return a source that resumes from _the next item_, not the
    same item that the state was paired with.

    Return `None` if for some reason this partition is no longer
    valid and can be skipped coherently. Raise an exception if
    not.

    Do not pre-build state about a partition in the
    constructor. All state must be derived from `resume_state` for
    recovery to work properly.

    Args:

        for_part: Which partition to build.

        resume_state: State data containing where in the input
            stream this partition should be begin on this invocation.

    Returns:

        The built partition, or `None`.

    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="bytewax.inputs.PartInput.list_parts"><code class="language-python name flex">
<span>def <span class="ident">list_parts</span></span>(<span>self) ‑> Iterable[str]</span>
</code></dt>
<dd>
<div class="desc"><p>List all partitions for this input by a string key.</p>
<p>This must consistently return the same keys when called by any
worker in a cluster.</p>
<p>Keys must be unique within this list.</p>
<h2 id="returns">Returns</h2>
<p>Partition keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@abstractmethod
def list_parts(self) -&gt; Iterable[str]:
    &#34;&#34;&#34;List all partitions for this input by a string key.

    This must consistently return the same keys when called by any
    worker in a cluster.

    Keys must be unique within this list.

    Returns:

        Partition keys.

    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
<footer class="api__footer" id="footer">
<p class="api__footer-copyright">
Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.
</p>
</footer>
</article>
<nav class="api__sidebar" id="sidebar">
<ul class="api__sidebar-nav" id="index">
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title">Super-module</h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item">
<a title="bytewax" href="/apidocs/">bytewax</a>
</li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-variables">Global variables</a></h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.inputs.PartIter" href="/apidocs/bytewax.inputs#bytewax.inputs.PartIter">PartIter</a></li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-classes">Classes</a></h3>
<ul class="api__sidebar-nav-classes">
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.inputs.PartInput" href="/apidocs/bytewax.inputs#bytewax.inputs.PartInput">PartInput</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.inputs.PartInput.build_part" href="/apidocs/bytewax.inputs#bytewax.inputs.PartInput.build_part">build_part</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.inputs.PartInput.list_parts" href="/apidocs/bytewax.inputs#bytewax.inputs.PartInput.list_parts">list_parts</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>